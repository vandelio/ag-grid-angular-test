{"ast":null,"code":"import { Injectable, InjectionToken, ɵɵdirectiveInject, INJECTOR, ɵglobal } from '@angular/core';\nimport { ReplaySubject } from 'rxjs';\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @return {?}\r\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction isAngularInTestMode() {\n  // This is safe to check for these properties in the following way since `typeof` does not\n  // throw an exception if the value does not exist in the scope.\n  // We should not try to read these values from the global scope (e.g. `ɵglobal` from the `@angular/core`).\n  // This is related to how these frameworks compile and execute modules. E.g. Jest wraps the module into\n  // its internal code where `jest` variable exists in the scope. It cannot be read from the global scope, e.g.\n  // this will return undefined `global.jest`, but `jest` will not equal undefined.\n  return typeof __karma__ !== 'undefined' || typeof jasmine !== 'undefined' || typeof jest !== 'undefined' || typeof Mocha !== 'undefined';\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nlet NgxsBootstrapper = /*#__PURE__*/(() => {\n  class NgxsBootstrapper {\n    constructor() {\n      /**\r\n       * Use `ReplaySubject`, thus we can get cached value even if the stream is completed\r\n       */\n      this.bootstrap$ = new ReplaySubject(1);\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    get appBootstrapped$() {\n      return this.bootstrap$.asObservable();\n    }\n    /**\r\n     * This event will be emitted after attaching `ComponentRef` of the root component\r\n     * to the tree of views, that's a signal that application has been fully rendered\r\n     * @return {?}\r\n     */\n\n\n    bootstrap() {\n      this.bootstrap$.next(true);\n      this.bootstrap$.complete();\n    }\n\n  }\n\n  NgxsBootstrapper.ɵfac = function NgxsBootstrapper_Factory(t) {\n    return new (t || NgxsBootstrapper)();\n  };\n\n  NgxsBootstrapper.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NgxsBootstrapper,\n    factory: NgxsBootstrapper.ɵfac\n  });\n  return NgxsBootstrapper;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * Use `ReplaySubject`, thus we can get cached value even if the stream is completed\r\n   * @type {?}\r\n   * @private\r\n   */\n  NgxsBootstrapper.prototype.bootstrap$;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} a\r\n * @param {?} b\r\n * @return {?}\r\n */\n\n\nfunction defaultEqualityCheck(a, b) {\n  return a === b;\n}\n/**\r\n * @param {?} equalityCheck\r\n * @param {?} prev\r\n * @param {?} next\r\n * @return {?}\r\n */\n\n\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false;\n  } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n  /** @type {?} */\n\n\n  const length = prev.length;\n\n  for (let i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Memoize a function on its last inputs only.\r\n * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\r\n *\r\n * @ignore\r\n * @template T\r\n * @param {?} func\r\n * @param {?=} equalityCheck\r\n * @return {?}\r\n */\n\n\nfunction memoize(func, equalityCheck = defaultEqualityCheck) {\n  /** @type {?} */\n  let lastArgs = null;\n  /** @type {?} */\n\n  let lastResult = null; // we reference arguments instead of spreading them for performance reasons\n\n  /**\r\n   * @return {?}\r\n   */\n\n  function memoized() {\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      lastResult =\n      /** @type {?} */\n      func.apply(null, arguments);\n    }\n\n    lastArgs = arguments;\n    return lastResult;\n  }\n\n  /** @type {?} */\n  memoized.reset =\n  /**\r\n  * @return {?}\r\n  */\n  function () {\n    // The hidden (for now) ability to reset the memoization\n    lastArgs = null;\n    lastResult = null;\n  };\n\n  return (\n    /** @type {?} */\n    memoized\n  );\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\n\nconst INITIAL_STATE_TOKEN = new InjectionToken('INITIAL_STATE_TOKEN');\nlet InitialState = /*#__PURE__*/(() => {\n  class InitialState {\n    /**\r\n     * @param {?} state\r\n     * @return {?}\r\n     */\n    static set(state) {\n      this.value = state;\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n\n    static pop() {\n      /** @type {?} */\n      const state = this.value;\n      this.value = {};\n      return state;\n    }\n\n  }\n\n  InitialState.value = {};\n  return InitialState;\n})();\n\nif (false) {\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n  InitialState.value;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @see StateContextFactory as it's referenced by this token to be accessed by plugins internally\r\n * @type {?}\r\n */\n\n\nconst NGXS_STATE_CONTEXT_FACTORY = new InjectionToken('Internals.StateContextFactory');\n/**\r\n * @see StateFactory as it's referenced by this token to be accessed by plugins internally\r\n * @type {?}\r\n */\n\nconst NGXS_STATE_FACTORY = new InjectionToken('Internals.StateFactory');\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n// Angular doesn't export `NG_FACTORY_DEF`.\n\n/** @type {?} */\n\nconst NG_FACTORY_DEF = 'ɵfac'; // A `Symbol` which is used to save the `Injector` onto the class instance.\n\n/** @type {?} */\n\nconst InjectorInstance = Symbol('InjectorInstance'); // A `Symbol` which is used to determine if factory has been decorated previously or not.\n\n/** @type {?} */\n\nconst FactoryHasBeenDecorated = Symbol('FactoryHasBeenDecorated'); // A `Symbol` which is used to save the notifier on the class instance. The `InjectorInstance` cannot\n// be retrieved within the `constructor` since it's set after the `factory()` is called.\n\n/** @type {?} */\n\nconst InjectorNotifier = Symbol('InjectorNotifier');\n/**\r\n * @record\r\n */\n\nfunction PrototypeWithInjectorNotifier() {}\n\nif (false) {\n  /* Skipping unnamed member:\r\n  [InjectorNotifier]?: ReplaySubject<boolean>;*/\n}\n/**\r\n * @param {?} target\r\n * @return {?}\r\n */\n\n\nfunction ensureInjectorNotifierIsCaptured(target) {\n  if (target[InjectorNotifier]) {\n    return (\n      /** @type {?} */\n      target[InjectorNotifier]\n    );\n  } else {\n    /** @type {?} */\n    const injectorNotifier$ = new ReplaySubject(1);\n    Object.defineProperty(target, InjectorNotifier, {\n      get:\n      /**\r\n      * @return {?}\r\n      */\n      () => injectorNotifier$\n    });\n    return injectorNotifier$;\n  }\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n/**\r\n * @param {?} target\r\n * @return {?}\r\n */\n\n\nfunction ensureLocalInjectorCaptured(target) {\n  if (FactoryHasBeenDecorated in target.constructor.prototype) {\n    return;\n  }\n  /** @type {?} */\n\n\n  const constructor = target.constructor; // Means we're in AOT mode.\n\n  if (typeof constructor[NG_FACTORY_DEF] === 'function') {\n    decorateFactory(constructor);\n  } else if (ngDevMode) {\n    // We're running in JIT mode and that means we're not able to get the compiled definition\n    // on the class inside the property decorator during the current message loop tick. We have\n    // to wait for the next message loop tick. Note that this is safe since this Promise will be\n    // resolved even before the `APP_INITIALIZER` is resolved.\n    // The below code also will be executed only in development mode, since it's never recommended\n    // to use the JIT compiler in production mode (by setting \"aot: false\").\n    decorateFactoryLater(constructor);\n  }\n\n  target.constructor.prototype[FactoryHasBeenDecorated] = true;\n}\n/**\r\n * @template T\r\n * @param {?} instance\r\n * @param {?} token\r\n * @return {?}\r\n */\n\n\nfunction localInject(instance, token) {\n  /** @type {?} */\n  const injector = instance[InjectorInstance];\n  return injector ? injector.get(token) : null;\n}\n/**\r\n * @param {?} constructor\r\n * @return {?}\r\n */\n\n\nfunction decorateFactory(constructor) {\n  /** @type {?} */\n  const factory = constructor[NG_FACTORY_DEF];\n\n  if (typeof factory !== 'function') {\n    return;\n  } // Let's try to get any definition.\n  // Caretaker note: this will be compatible only with Angular 9+, since Angular 9 is the first\n  // Ivy-stable version. Previously definition properties were named differently (e.g. `ngComponentDef`).\n\n  /** @type {?} */\n\n\n  const def = constructor.ɵprov || constructor.ɵpipe || constructor.ɵcmp || constructor.ɵdir;\n  /** @type {?} */\n\n  const decoratedFactory =\n  /**\r\n  * @return {?}\r\n  */\n  () => {\n    /** @type {?} */\n    const instance = factory(); // Caretaker note: `inject()` won't work here.\n    // We can use the `directiveInject` only during the component\n    // construction, since Angular captures the currently active injector.\n    // We're not able to use this function inside the getter (when the `selectorId` property is\n    // requested for the first time), since the currently active injector will be null.\n\n    instance[InjectorInstance] = ɵɵdirectiveInject( // We're using `INJECTOR` token except of the `Injector` class since the compiler\n    // throws: `Cannot assign an abstract constructor type to a non-abstract constructor type.`.\n    // Caretaker note: that this is the same way of getting the injector.\n    INJECTOR); // Caretaker note: the notifier will be available only if consumers call the `ensureInjectorNotifierIsCaptured()`.\n\n    /** @type {?} */\n\n    const injectorNotifier$ = instance[InjectorNotifier];\n\n    if (injectorNotifier$) {\n      injectorNotifier$.next(true);\n      injectorNotifier$.complete();\n    }\n\n    return instance;\n  }; // If we've found any definition then it's enough to override the `def.factory` since Angular\n  // code uses the `def.factory` and then fallbacks to `ɵfac`.\n\n\n  if (def) {\n    def.factory = decoratedFactory;\n  } // `@NgModule()` doesn't doesn't have definition factory, also providers have definitions but Angular\n  // still uses the `ɵfac`.\n\n\n  Object.defineProperty(constructor, NG_FACTORY_DEF, {\n    get:\n    /**\r\n    * @return {?}\r\n    */\n    () => decoratedFactory\n  });\n}\n/**\r\n * @param {?} constructor\r\n * @return {?}\r\n */\n\n\nfunction decorateFactoryLater(constructor) {\n  // This function actually will be tree-shaken away when building for production since it's guarded with `ngDevMode`.\n  // We're having the `try-catch` here because of the `SyncTestZoneSpec`, which throws\n  // an error when micro or macrotask is used within a synchronous test. E.g. `Cannot call\n  // Promise.then from within a sync test`.\n  try {\n    Promise.resolve().then(\n    /**\r\n    * @return {?}\r\n    */\n    () => {\n      decorateFactory(constructor);\n    });\n  } catch (_a) {\n    // This is kind of a \"hack\", but we try to be backwards-compatible,\n    // tho this `catch` block will only be executed when tests are run with Jasmine or Jest.\n    ɵglobal.process && ɵglobal.process.nextTick && ɵglobal.process.nextTick(\n    /**\r\n    * @return {?}\r\n    */\n    () => {\n      decorateFactory(constructor);\n    });\n  }\n}\n/**\r\n * @record\r\n */\n\n\nfunction Definition() {}\n\nif (false) {\n  /** @type {?} */\n  Definition.prototype.factory;\n}\n/**\r\n * @record\r\n */\n\n\nfunction ConstructorWithDefinitionAndFactory() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  ConstructorWithDefinitionAndFactory.prototype.ɵprov;\n  /** @type {?|undefined} */\n\n  ConstructorWithDefinitionAndFactory.prototype.ɵpipe;\n  /** @type {?|undefined} */\n\n  ConstructorWithDefinitionAndFactory.prototype.ɵcmp;\n  /** @type {?|undefined} */\n\n  ConstructorWithDefinitionAndFactory.prototype.ɵdir;\n  /* Skipping unnamed member:\r\n  [NG_FACTORY_DEF]?: Factory;*/\n}\n/**\r\n * @record\r\n */\n\n\nfunction PrivateInstance() {}\n\nif (false) {\n  /* Skipping unnamed member:\r\n  [InjectorInstance]?: Injector;*/\n\n  /* Skipping unnamed member:\r\n  [InjectorNotifier]?: ReplaySubject<boolean>;*/\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nexport { INITIAL_STATE_TOKEN, InitialState, NGXS_STATE_CONTEXT_FACTORY, NGXS_STATE_FACTORY, NgxsBootstrapper, ensureInjectorNotifierIsCaptured, ensureLocalInjectorCaptured, isAngularInTestMode, localInject, memoize }; //# sourceMappingURL=ngxs-store-internals.js.map","map":null,"metadata":{},"sourceType":"module"}